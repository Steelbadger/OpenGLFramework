#version 400 core

layout(triangles, equal_spacing, ccw) in;
in vec2 tcUV[];
in vec3 tcworldPosition[];
in vec3 tcnormal[];
in vec3 tcvertNorm[];
in vec3 tcglobalPos[];

out vec2 UV;
out vec3 worldPosition;
out vec3 normal;
out vec3 vertNorm;
out vec3 globalPos;

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 normalMatrix;
uniform sampler2D texture3;

void main()
{
    vec4 p0 = gl_TessCoord.x * gl_in[0].gl_Position;
    vec4 p1 = gl_TessCoord.y * gl_in[1].gl_Position;
    vec4 p2 = gl_TessCoord.z * gl_in[2].gl_Position;

	vec4 pos = (p0 + p1 + p2);

	pos.y  = texture(texture3, vec2(pos.x/1000.0, pos.z/1000.0)).a*160 - 80;

    gl_Position = projectionMatrix * modelViewMatrix * pos;

	vec2 uv0 = gl_TessCoord.x * tcUV[0];
	vec2 uv1 = gl_TessCoord.y * tcUV[1];
	vec2 uv2 = gl_TessCoord.z * tcUV[2];

	UV = (uv0 + uv1 + uv2);

    vec3 wp0 = gl_TessCoord.x * tcworldPosition[0];
    vec3 wp1 = gl_TessCoord.y * tcworldPosition[1];
    vec3 wp2 = gl_TessCoord.z * tcworldPosition[2];

//	worldPosition = (wp0 + wp1 + wp2);
	worldPosition = vec3(modelViewMatrix * pos);

    vec3 n0 = gl_TessCoord.x * tcnormal[0];
    vec3 n1 = gl_TessCoord.y * tcnormal[1];
    vec3 n2 = gl_TessCoord.z * tcnormal[2];

	vec3 norm = texture(texture3, vec2(pos.x/1000.0, pos.z/1000.0)).rgb-0.5;
	norm = normalize(norm);


//	normal = vec3(normalMatrix * vec4(normalize(n0 + n1 + n2), 1.0));
	normal = vec3(normalMatrix * vec4(norm, 1.0));

    vec3 vn0 = gl_TessCoord.x * tcvertNorm[0];
    vec3 vn1 = gl_TessCoord.y * tcvertNorm[1];
    vec3 vn2 = gl_TessCoord.z * tcvertNorm[2];

//	vertNorm = normalize(vn0 + vn1 + vn2);
	vertNorm = norm;

    vec3 gp0 = gl_TessCoord.x * tcglobalPos[0];
    vec3 gp1 = gl_TessCoord.y * tcglobalPos[1];
    vec3 gp2 = gl_TessCoord.z * tcglobalPos[2];

//	globalPos = (gp0 + gp1 + gp2);
	globalPos = vec3(pos);

}