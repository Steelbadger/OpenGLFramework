#version 330 core


in vec2 UV;
in vec3 worldPosition;
in vec3 normal;
in vec3 vertNorm;
in vec3 globalPos;

// Ouput data
out vec3 color;

uniform sampler2D texture;
uniform sampler2D rock;

struct Light {
	vec4 position;
	vec4 colour;
};

uniform Light sun;

void main()
{
	vec3 lightcolour = vec3(sun.colour);
	vec3 texcolour;

	vec3 baseline = vec3(vertNorm.x, 0.0, vertNorm.z);
	baseline = normalize(baseline);
	vec3 vn = normalize(vertNorm);

	float angle = abs(dot(vn, baseline));

	float grassThresh = 0.45;
	float rockThresh = 0.55;
	angle = max(grassThresh, angle);
	angle = min(rockThresh, angle);


	float alt = globalPos.y;
	alt = min(2.0, alt);
	alt = max(1.6, alt);
	alt = alt-1.6;

	float portion = (angle-grassThresh)/(rockThresh-grassThresh);
	texcolour = portion*texture2D(rock, UV/4).rgb + (1-portion)*texture2D(texture, UV).rgb;

	texcolour = (alt/0.4) * texcolour + (1-(alt/0.4)) * (texture2D(rock, UV/4).rgb * vec3(0.543, 0.36, 0.36));

	float distance = distance(vec3(0.0, 0.0, 0.0), worldPosition);



	vec3 ambient = texcolour * lightcolour * sun.colour.w;
	vec3 direction = vec3(sun.position);

	vec3 fragToLight = normalize(direction);

	vec3 surfaceNormal = normalize(normal);
	
	vec3 fragToView = normalize(-worldPosition);

	float diffuseContribution = max(0.0, dot(surfaceNormal, fragToLight));

	vec3 diffuse = texcolour * lightcolour * diffuseContribution * (1-sun.colour.w);

	fragToLight = normalize(-worldPosition);

	diffuseContribution = max(0.0, dot(surfaceNormal, fragToLight));

	diffuse = diffuse + (texcolour * lightcolour * diffuseContribution * (1/(1 + 0.01*distance + 0.0001 * distance * distance)));

	color = ambient + diffuse;
}